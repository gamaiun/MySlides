<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>MySlide</title>
    <style>
      @media print {
        html,
        body {
          width: 100%;
          height: 100%;
          margin: 0 !important;
          padding: 0 !important;
          overflow: hidden !important;
        }
        #printBtn {
          visibility: hidden !important;
        }
        #datetimeHeader {
          display: block !important;
          position: static !important;
          margin-top: 0.5cm !important;
          margin-bottom: 0.3cm !important;
        }
        .controls {
          margin-bottom: 0.3cm !important;
        }
        #layout {
          width: 100% !important;
          height: 100% !important;
          max-width: 100% !important;
          max-height: 100% !important;
          min-height: 0 !important;
          margin: 0 !important;
          padding: 0 !important;
          box-sizing: border-box !important;
          display: flex !important;
          flex-direction: column !important;
        }
        #imageContainer {
          flex: 1 1 auto !important;
          width: 100% !important;
          height: 100% !important;
          max-width: 100% !important;
          max-height: 100% !important;
          margin: 0 !important;
          padding: 0 !important;
          box-sizing: border-box !important;
        }
      }
      @page {
        size: landscape;
        margin: 0.5cm;
      }
      body {
        font-family: Arial, sans-serif;
        font-size: 16px;
        margin: 0;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        box-sizing: border-box;
        /* Reduce top padding to bring content closer to the top */
        padding: 8px 40px 40px 40px;
        display: flex;
        flex-direction: column;
      }
      #layout {
        border: none;
        padding: 0;
        /* Use the full available content width (body padding already applied) */
        width: 100%;
        max-width: calc(100% - 80px);
        position: relative;
        display: flex;
        flex-direction: column;
        box-sizing: border-box;
        margin: 0;
        /* align items to the start so children (image) line up with the title's left edge */
        align-items: flex-start;
        flex: 1;
      }
      .controls {
        margin-bottom: 0;
        width: 1268px;
        box-sizing: border-box;
        margin: 0 auto;
      }
      #textInput {
        width: 98%;
        box-sizing: border-box;
        font-family: Arial, sans-serif;
        font-size: 13px;
        resize: vertical;
        min-width: 100px;
        max-width: 98%;
        max-height: 200px;
      }
      /* Fixed target image area to match imported image dimensions exactly (increased by 10%) */
      #imageContainer {
        /* slightly increase width (6%) to use spare space on the right (was 4%) */
        width: calc(100% + 6%);
        height: 656px; /* reduced earlier */
        /* allow it to grow slightly beyond parent width */
        max-width: calc(100% + 6%);
        background: #f9f9f9;
        border: 1px dashed #bbb;
        overflow: hidden;
        margin: 0;
        position: relative;
        box-sizing: border-box;
        flex: 0 0 auto;
      }
      /* overlay header positioned over the image area */
      .overlay-header {
        position: absolute;
        top: 8px;
        left: 12px;
        right: 12px;
        z-index: 10;
        color: #222;
        font-weight: bold;
        pointer-events: auto;
        display: flex;
        flex-direction: column;
        gap: 6px;
        align-items: flex-start;
      }
      .overlay-textarea {
        width: 98%;
        box-sizing: border-box;
        font-family: Arial, sans-serif;
        font-size: 13px;
        padding: 6px 8px;
        background: transparent; /* fully transparent background */
        border: none; /* no border */
        outline: none;
        border-radius: 0;
        resize: vertical;
        min-height: 30px;
        max-height: 160px;
      }
      #datetimeHeader {
        max-width: 900px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .top-bar {
        width: 98%;
        margin: 0 auto 10px auto;
        display: flex;
        align-items: center;
        justify-content: space-between;
        box-sizing: border-box;
      }
    </style>
  </head>
  <body>
    <!-- header moved to overlay inside #layout to free vertical space -->
    <div class="controls">
      <!-- Removed duplicate text input -->
    </div>
    <div id="layout">
      <!-- overlay header sits on top of image area -->
      <div class="overlay-header">
        <div
          id="datetimeHeader"
          contenteditable="true"
          spellcheck="false"
          title="Click to edit."
          style="
            font-size: 1.1em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
          "
        ></div>
        <textarea
          id="textInputOverlay"
          class="overlay-textarea"
          placeholder="Enter your text here"
        ></textarea>
      </div>
      <!-- Removed textPreview -->
      <div id="imageContainer" style="position: relative"></div>
    </div>
    <script>
      const textInput = document.getElementById("textInput");
      const imageContainer = document.getElementById("imageContainer");
      const datetimeHeader = document.getElementById("datetimeHeader");

      // Trigger Browse Image on click anywhere in image area
      // imageContainer.addEventListener("click", () => {
      //   window.electronAPI.openImageDialog();
      // });

      let isHeaderEdited = false;
      function getDefaultHeaderText() {
        const now = new Date();
        const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        const months = [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sept",
          "Oct",
          "Nov",
          "Dec",
        ];
        const dayAbbr = days[now.getDay()];
        const monthAbbr = months[now.getMonth()];
        const dayOfMonth = now.getDate();
        const nyOptions = {
          timeZone: "America/New_York",
          hour: "2-digit",
          minute: "2-digit",
          hour12: false,
        };
        const nyTime = now.toLocaleTimeString("en-US", nyOptions);
        const ilOptions = {
          timeZone: "Asia/Jerusalem",
          hour: "2-digit",
          minute: "2-digit",
          hour12: false,
        };
        const ilTime = now.toLocaleTimeString("en-US", ilOptions);
        return `${dayAbbr} ${monthAbbr} ${dayOfMonth} | New York: ${nyTime} | Israel: ${ilTime}`;
      }
      function updateDatetimeHeader() {
        if (!isHeaderEdited) {
          datetimeHeader.textContent = getDefaultHeaderText();
        }
      }
      updateDatetimeHeader();
      setInterval(updateDatetimeHeader, 10000);

      datetimeHeader.addEventListener("input", () => {
        isHeaderEdited = true;
      });
      datetimeHeader.addEventListener("blur", () => {
        // If user clears the header, restore default
        if (datetimeHeader.textContent.trim() === "") {
          isHeaderEdited = false;
          updateDatetimeHeader();
        }
      });

      // Listen for menu-triggered Browse Image
      window.electronAPI.onMenuBrowseImage(() => {
        window.electronAPI.openImageDialog();
      });

      // Listen for menu Print -> save as PDF (main process will then open print dialog)
      window.electronAPI.onMenuPrint(() => {
        // call preload's saveAsPDF handler; options can be passed if needed
        window.electronAPI.saveAsPDF({}).then?.(() => {});
      });

      // When main notifies PDF saved, trigger print dialog from renderer (allowed)
      window.electronAPI.onPDFSaved((event, result) => {
        if (result && result.success) {
          // call native print dialog from renderer context
          try {
            window.print();
          } catch (e) {
            console.error("window.print failed", e);
          }
        } else {
          console.error("PDF save failed", result && result.error);
        }
      });

      // Listen for menu Snip -> start snipping tool via main
      window.electronAPI.onMenuSnip(() => {
        window.electronAPI.startSnip();
      });

      // Listen for selected image path from main process
      window.electronAPI.onImageSelected((event, filePath) => {
        imageContainer.innerHTML = "";
        if (filePath) {
          // Load image to get natural size
          const imgObj = new window.Image();
          imgObj.src = `file://${filePath}`;
          imgObj.onload = function () {
            const aspectRatio = imgObj.naturalWidth / imgObj.naturalHeight;
            // Get container width and height
            const containerWidth = imageContainer.offsetWidth;
            const containerHeight = imageContainer.offsetHeight;
            // Fit image height to container height, snap bottom to container bottom
            let newHeight = containerHeight;
            let newWidth = newHeight * aspectRatio;
            // If newWidth > containerWidth, fit width instead
            if (newWidth > containerWidth) {
              newWidth = containerWidth;
              newHeight = newWidth / aspectRatio;
            }
            // Create wrapper with image fit to container, bottom snapped
            const wrapper = document.createElement("div");
            wrapper.className = "crop-wrapper";
            wrapper.style.left = (containerWidth - newWidth) / 2 + "px";
            wrapper.style.top = containerHeight - newHeight + "px";
            wrapper.style.width = newWidth + "px";
            wrapper.style.height = newHeight + "px";
            wrapper.style.position = "absolute";
            wrapper.style.zIndex = "2";

            // Create image
            const img = document.createElement("img");
            img.src = `file://${filePath}`;
            // img.className = "crop-img";
            img.style.height = "100%";
            img.style.width = "auto";
            img.style.position = "absolute";
            img.style.left = "50%";
            img.style.transform = "translateX(-50%)";
            img.style.bottom = "0px";
            img.style.filter = "grayscale(100%) invert(100%)";
            img.draggable = false;
            wrapper.appendChild(img);

            // Add resize handle
            const handle = document.createElement("div");
            handle.className = "resize-handle";
            wrapper.appendChild(handle);

            imageContainer.appendChild(wrapper);

            // Drag logic for wrapper
            let isDragging = false,
              dragStartX = 0,
              dragStartY = 0,
              startLeft = 0,
              startTop = 0;
            wrapper.addEventListener("mousedown", function (e) {
              if (e.target === handle) return;
              isDragging = true;
              dragStartX = e.clientX;
              dragStartY = e.clientY;
              startLeft = parseInt(wrapper.style.left);
              startTop = parseInt(wrapper.style.top);
              if (isNaN(startLeft)) startLeft = 0;
              if (isNaN(startTop)) startTop = 0;
              document.body.style.userSelect = "none";
              window.addEventListener("mousemove", dragMove);
              window.addEventListener("mouseup", dragEnd);
            });
            function dragMove(e) {
              if (isDragging) {
                let dx = e.clientX - dragStartX;
                let dy = e.clientY - dragStartY;
                let newLeft = startLeft + dx;
                let newTop = startTop + dy;
                // Prevent moving image above bottom
                newTop = Math.min(newTop, containerHeight - newHeight);
                wrapper.style.left = newLeft + "px";
                wrapper.style.top = newTop + "px";
              }
            }
            function dragEnd() {
              isDragging = false;
              document.body.style.userSelect = "";
              window.removeEventListener("mousemove", dragMove);
              window.removeEventListener("mouseup", dragEnd);
            }

            // Resize logic (aspect ratio locked, no max limit)
            let isResizing = false,
              resizeStartX = 0,
              resizeStartY = 0,
              startWidth = 0,
              startHeight = 0;
            handle.addEventListener("mousedown", function (e) {
              e.stopPropagation();
              isResizing = true;
              resizeStartX = e.clientX;
              resizeStartY = e.clientY;
              startWidth = wrapper.offsetWidth;
              startHeight = wrapper.offsetHeight;
              document.body.style.userSelect = "none";
              window.addEventListener("mousemove", resizeMove);
              window.addEventListener("mouseup", resizeEnd);
            });
            function resizeMove(e) {
              if (isResizing) {
                let dw = e.clientX - resizeStartX;
                let newWidth = Math.max(50, startWidth + dw);
                let newHeight = newWidth / aspectRatio;
                // Snap bottom to container bottom
                let newTop = containerHeight - newHeight;
                wrapper.style.width = newWidth + "px";
                wrapper.style.height = newHeight + "px";
                wrapper.style.top = newTop + "px";
              }
            }
            function resizeEnd() {
              isResizing = false;
              document.body.style.userSelect = "";
              window.removeEventListener("mousemove", resizeMove);
              window.removeEventListener("mouseup", resizeEnd);
            }
          };
        }
      });

      // Listen for paste event to insert clipboard image
      window.addEventListener("paste", (event) => {
        const items = event.clipboardData && event.clipboardData.items;
        if (!items) return;
        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          if (item.type.indexOf("image") !== -1) {
            const blob = item.getAsFile();
            const imgObj = new window.Image();
            const url = URL.createObjectURL(blob);
            imgObj.src = url;
            imgObj.onload = function () {
              imageContainer.innerHTML = "";
              const aspectRatio = imgObj.naturalWidth / imgObj.naturalHeight;
              const containerWidth = imageContainer.offsetWidth;
              const containerHeight = imageContainer.offsetHeight;
              const newWidth = containerWidth;
              const newHeight = newWidth / aspectRatio;
              const wrapper = document.createElement("div");
              wrapper.className = "crop-wrapper";
              // center horizontally and snap bottom to container
              wrapper.style.left = (containerWidth - newWidth) / 2 + "px";
              wrapper.style.top = containerHeight - newHeight + "px";
              wrapper.style.width = newWidth + "px";
              wrapper.style.height = newHeight + "px";
              wrapper.style.position = "absolute";
              wrapper.style.zIndex = "2";
              const img = document.createElement("img");
              img.src = url;
              img.className = "crop-img";
              // match styles used for file-imported images so pasted images snap to bottom
              img.style.height = "100%";
              img.style.width = "auto";
              img.style.position = "absolute";
              img.style.left = "50%";
              img.style.transform = "translateX(-50%)";
              img.style.bottom = "0px";
              img.style.filter = "grayscale(100%) invert(100%)";
              img.draggable = false;
              wrapper.appendChild(img);
              const handle = document.createElement("div");
              handle.className = "resize-handle";
              wrapper.appendChild(handle);
              imageContainer.appendChild(wrapper);
              // Drag logic for wrapper
              let isDragging = false,
                dragStartX = 0,
                dragStartY = 0,
                startLeft = 0,
                startTop = 0;
              wrapper.addEventListener("mousedown", function (e) {
                if (e.target === handle) return;
                isDragging = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                startLeft = parseInt(wrapper.style.left);
                startTop = parseInt(wrapper.style.top);
                if (isNaN(startLeft)) startLeft = 0;
                if (isNaN(startTop)) startTop = 0;
                document.body.style.userSelect = "none";
                window.addEventListener("mousemove", dragMove);
                window.addEventListener("mouseup", dragEnd);
              });
              function dragMove(e) {
                if (isDragging) {
                  let dx = e.clientX - dragStartX;
                  let dy = e.clientY - dragStartY;
                  let newLeft = startLeft + dx;
                  let newTop = startTop + dy;
                  // Prevent moving image above bottom
                  newTop = Math.min(newTop, containerHeight - newHeight);
                  wrapper.style.left = newLeft + "px";
                  wrapper.style.top = newTop + "px";
                }
              }
              function dragEnd() {
                isDragging = false;
                document.body.style.userSelect = "";
                window.removeEventListener("mousemove", dragMove);
                window.removeEventListener("mouseup", dragEnd);
              }
              // Resize logic (aspect ratio locked, no max limit)
              let isResizing = false,
                resizeStartX = 0,
                resizeStartY = 0,
                startWidth = 0,
                startHeight = 0;
              handle.addEventListener("mousedown", function (e) {
                e.stopPropagation();
                isResizing = true;
                resizeStartX = e.clientX;
                resizeStartY = e.clientY;
                startWidth = wrapper.offsetWidth;
                startHeight = wrapper.offsetHeight;
                document.body.style.userSelect = "none";
                window.addEventListener("mousemove", resizeMove);
                window.addEventListener("mouseup", resizeEnd);
              });
              function resizeMove(e) {
                if (isResizing) {
                  let dw = e.clientX - resizeStartX;
                  let newWidth = Math.max(50, startWidth + dw);
                  let newHeight = newWidth / aspectRatio;
                  // Snap bottom to container bottom
                  let newTop = containerHeight - newHeight;
                  wrapper.style.width = newWidth + "px";
                  wrapper.style.height = newHeight + "px";
                  wrapper.style.top = newTop + "px";
                }
              }
              function resizeEnd() {
                isResizing = false;
                document.body.style.userSelect = "";
                window.removeEventListener("mousemove", resizeMove);
                window.removeEventListener("mouseup", resizeEnd);
              }
            };
            break;
          }
        }
      });

      // Listen for snip image from main process
      window.electronAPI.onSnipImage = (callback) => {
        window.electronAPI._snipImageHandler = (event, imageUrl) =>
          callback(imageUrl);
        window.electronAPI._snipImageListener =
          window.electronAPI._snipImageListener ||
          window.electronAPI._snipImageHandler;
        window.electronAPI._ipcRenderer =
          window.electronAPI._ipcRenderer || require("electron").ipcRenderer;
        window.electronAPI._ipcRenderer.on(
          "snip-image",
          window.electronAPI._snipImageListener
        );
      };
      window.electronAPI.onSnipImage((imageUrl) => {
        if (imageUrl) {
          imageContainer.innerHTML = "";
          const imgObj = new window.Image();
          imgObj.src = imageUrl;
          imgObj.onload = function () {
            const aspectRatio = imgObj.naturalWidth / imgObj.naturalHeight;
            const containerWidth = imageContainer.offsetWidth;
            const containerHeight = imageContainer.offsetHeight;
            let newWidth = containerWidth;
            let newHeight = newWidth / aspectRatio;
            if (newHeight < containerHeight) {
              newHeight = containerHeight;
              newWidth = newHeight * aspectRatio;
            }
            // If newWidth > containerWidth, fit width instead
            if (newWidth > containerWidth) {
              newWidth = containerWidth;
              newHeight = newWidth / aspectRatio;
            }
            const wrapper = document.createElement("div");
            wrapper.className = "crop-wrapper";
            wrapper.style.left = (containerWidth - newWidth) / 2 + "px";
            wrapper.style.top = containerHeight - newHeight + "px";
            wrapper.style.width = newWidth + "px";
            wrapper.style.height = newHeight + "px";
            wrapper.style.position = "absolute";
            wrapper.style.zIndex = "2";
            const img = document.createElement("img");
            img.src = imageUrl;
            img.className = "crop-img";
            img.draggable = false;
            wrapper.appendChild(img);
            const handle = document.createElement("div");
            handle.className = "resize-handle";
            wrapper.appendChild(handle);
            imageContainer.appendChild(wrapper);
            // Drag and resize logic as before...
          };
        }
      });
    </script>
  </body>
</html>
