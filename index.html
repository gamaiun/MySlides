<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>MySlide</title>
    <style>
      @media print {
        html,
        body {
          width: 100%;
          height: 100%;
          margin: 0;
          padding: 0;
          overflow: hidden;
        }
        #layout {
          width: 100%;
          height: 95%; /* Lower the printed area by 5% */
          margin: 0;
          padding: 0;
          display: flex;
          flex-direction: column;
          justify-content: flex-end; /* Align to bottom */
          align-items: flex-end; /* Align to right */
        }
        #imageContainer {
          width: 100%;
          height: 95%; /* Lower the printed area by 5% */
          margin: 0;
          padding: 0;
          display: flex;
          justify-content: flex-end; /* Align image to right */
          align-items: flex-end; /* Align image to bottom */
          overflow-x: hidden;
          overflow-y: visible;
        }
        #imageContainer img {
          width: auto !important;
          max-width: 100% !important;
          height: 100% !important;
          object-fit: contain !important;
          object-position: right bottom !important;
          position: absolute !important;
          right: 0 !important;
          bottom: 0 !important;
          left: auto !important;
          top: auto !important;
          margin: 0 !important;
          padding: 0 !important;
        }
      }
      @page {
        size: landscape;
        margin: 0.5cm;
      }
      body {
        font-family: Arial, sans-serif;
        font-size: 16px;
        margin: 0;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        box-sizing: border-box;
        /* Reduce top padding to bring content closer to the top */
        padding: 8px 40px 40px 40px;
        display: flex;
        flex-direction: column;
        background-color: white; /* Change background to white */
        color: black; /* Ensure text is visible on white background */
      }
      #layout {
        border: none;
        padding: 0;
        /* Use the full available content width (body padding already applied) */
        width: 100%;
        max-width: calc(100% - 80px);
        position: relative;
        display: flex;
        flex-direction: column;
        box-sizing: border-box;
        margin: 0;
        /* align items to the start so children (image) line up with the title's left edge */
        align-items: flex-start;
        flex: 1;
      }
      .controls {
        margin-bottom: 0;
        width: 1268px;
        box-sizing: border-box;
        margin: 0 auto;
      }
      #textInput {
        width: 98%;
        box-sizing: border-box;
        font-family: Arial, sans-serif;
        font-size: 13px;
        resize: vertical;
        min-width: 100px;
        max-width: 98%;
        max-height: 200px;
      }
      /* Fixed target image area to match imported image dimensions exactly (increased by 10%) */
      #imageContainer {
        /* slightly increase width (6%) to use spare space on the right (was 4%) */
        width: calc(100% + 10%); /* Enlarged width by 12% */
        height: calc(100% + 2%); /* Enlarged height by 6% */
        /* allow it to grow slightly beyond parent width */
        max-width: none; /* Remove the constraint on maximum width */
        background: #f9f9f9;
        border: 1px dashed #bbb;
        overflow: hidden;
        margin: 0;
        position: relative;
        box-sizing: border-box;
        flex: 0 0 auto;
        padding: 0 !important;
        display: flex;
        justify-content: center;
        align-items: flex-end; /* Ensure image aligns to the bottom */
        overflow-x: hidden; /* Hide overflow on the left if image is too wide */
        overflow-y: visible;
        justify-content: flex-end; /* Align image to the right */
        align-items: flex-end; /* Align image to the bottom */
      }
      #imageContainer img {
        width: auto;
        height: 100%; /* Image height fits container */
        object-fit: cover; /* Crop left side if too wide, show right side */
        object-position: right bottom; /* Always show right side and bottom of image */
        position: absolute;
        right: 0;
        bottom: 0;
        left: auto;
        top: auto;
        margin: 0;
        padding: 0;
      }
      /* overlay header positioned over the image area */
      .overlay-header {
        position: absolute;
        top: 8px;
        left: 12px;
        right: 12px;
        z-index: 10;
        color: #222;
        font-weight: bold;
        pointer-events: auto;
        display: flex;
        flex-direction: column;
        gap: 6px;
        align-items: flex-start;
        overflow: visible; /* Ensure new elements are not hidden */
        height: auto; /* Allow the container to expand with content */
      }
      .overlay-textarea {
        width: 200px;
        min-width: 200px;
        max-width: 200px;
        box-sizing: border-box;
        font-family: Arial, sans-serif;
        font-size: 14px;
        padding: 5px 3px;
        background: transparent; /* fully transparent background */
        border: none; /* no border */
        outline: none;
        border-radius: 0;
        text-align: left; /* Ensure text alignment matches title */
        background-color: white; /* Change text area background to white */
        color: black; /* Ensure text is visible */
        margin-bottom: 2px;
        height: 20px;
        min-height: 20px;
        max-height: 20px;
        overflow: hidden;
        resize: none;
      }
      #datetimeHeader {
        max-width: 900px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        text-align: left; /* Ensure title alignment matches text */
      }
      .top-bar {
        width: 98%;
        margin: 0 auto 10px auto;
        display: flex;
        align-items: center;
        justify-content: space-between;
        box-sizing: border-box;
      }
      img {
        filter: none !important; /* Cancel the invert colors functionality */
      }
      #textInputOverlay {
        background-color: transparent !important; /* Ensure the text area background is fully transparent */
      }
      #imageContainer img {
        width: 100%;
        height: auto;
        object-fit: contain;
        margin: 0; /* Remove any margin */
        padding: 0; /* Remove any padding */
        position: absolute; /* Ensure the image aligns perfectly within the container */
        top: 0;
        left: 0;
      }
      .field-row {
        display: flex;
        align-items: center;
        margin-bottom: 2px;
      }
      .field-label {
        min-width: 70px;
        font-size: 13px;
        color: #222;
        margin-right: 8px;
      }
    </style>
  </head>
  <body>
    <!-- header moved to overlay inside #layout to free vertical space -->
    <div class="controls">
      <!-- Removed duplicate text input -->
    </div>
    <div id="layout">
      <!-- overlay header sits on top of image area -->
      <div class="overlay-header">
        <div
          id="datetimeHeader"
          contenteditable="true"
          spellcheck="false"
          title="Click to edit."
          style="
            font-size: 1.1em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
          "
        ></div>
        <div class="field-row">
          <label for="toFindInput" class="field-label">To Find:</label
          ><textarea id="toFindInput" class="overlay-textarea"></textarea>
        </div>
        <div class="field-row">
          <label for="measureInput" class="field-label">Measure:</label
          ><textarea id="measureInput" class="overlay-textarea"></textarea>
        </div>
        <div class="field-row">
          <label for="ofSizeInput" class="field-label">Of Size:</label
          ><textarea id="ofSizeInput" class="overlay-textarea"></textarea>
        </div>
        <div class="field-row">
          <label for="fromInput" class="field-label">From:</label
          ><textarea id="fromInput" class="overlay-textarea"></textarea>
        </div>
        <div class="field-row">
          <span class="field-label">Comment:</span>
          <textarea class="overlay-textarea" rows="1"></textarea>
        </div>
        <div class="field-row">
          <span id="date-under-commentary" class="field-label"></span>
        </div>
      </div>
      <!-- Removed textPreview -->
      <div id="imageContainer" style="position: relative"></div>
    </div>
    <script>
      const textInput = document.getElementById("textInput");
      const imageContainer = document.getElementById("imageContainer");
      const datetimeHeader = document.getElementById("datetimeHeader");

      // Trigger Browse Image on click anywhere in image area
      // imageContainer.addEventListener("click", () => {
      //   window.electronAPI.openImageDialog();
      // });

      let isHeaderEdited = false;
      function getDefaultHeaderText() {
        const now = new Date();
        const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        const months = [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sept",
          "Oct",
          "Nov",
          "Dec",
        ];
        const dayAbbr = days[now.getDay()];
        const monthAbbr = months[now.getMonth()];
        const dayOfMonth = now.getDate();
        const nyOptions = {
          timeZone: "America/New_York",
          hour: "2-digit",
          minute: "2-digit",
          hour12: false,
        };
        const nyTime = now.toLocaleTimeString("en-US", nyOptions);
        return `${dayAbbr} ${monthAbbr} ${dayOfMonth} | New York: ${nyTime}`;
      }
      function updateDatetimeHeader() {
        if (!isHeaderEdited) {
          datetimeHeader.textContent = getDefaultHeaderText();
        }
      }
      updateDatetimeHeader();
      setInterval(updateDatetimeHeader, 10000);

      function setDateUnderCommentary() {
        const dateElement = document.getElementById("date-under-commentary");
        if (dateElement) {
          dateElement.textContent = "Printed: " + getDefaultHeaderText();
          dateElement.style.fontWeight = "normal";
        }
      }
      setDateUnderCommentary();
      setInterval(setDateUnderCommentary, 10000);

      datetimeHeader.addEventListener("input", () => {
        isHeaderEdited = true;
      });
      datetimeHeader.addEventListener("blur", () => {
        // If user clears the header, restore default
        if (datetimeHeader.textContent.trim() === "") {
          isHeaderEdited = false;
          updateDatetimeHeader();
        }
      });

      // Listen for menu-triggered Browse Image
      window.electronAPI.onMenuBrowseImage(() => {
        window.electronAPI.openImageDialog();
      });

      // Listen for menu Print -> save as PDF (main process will then open print dialog)
      window.electronAPI.onMenuPrint(() => {
        // call preload's saveAsPDF handler; options can be passed if needed
        window.electronAPI.saveAsPDF({}).then?.(() => {});
      });

      // When main notifies PDF saved, trigger print dialog from renderer (allowed)
      window.electronAPI.onPDFSaved((event, result) => {
        if (result && result.success) {
          // call native print dialog from renderer context
          try {
            window.print();
          } catch (e) {
            console.error("window.print failed", e);
          }
        } else {
          console.error("PDF save failed", result && result.error);
        }
      });

      // Listen for menu Snip -> start snipping tool via main
      window.electronAPI.onMenuSnip(() => {
        window.electronAPI.startSnip();
      });

      // Listen for selected image path from main process
      window.electronAPI.onImageSelected((event, filePath) => {
        imageContainer.innerHTML = "";
        if (filePath) {
          const img = new Image();
          img.src = `file://${filePath}`;
          img.onload = () => {
            img.style.width =
              "100%"; /* Scale image to fit the width of the image area */
            img.style.height =
              "100%"; /* Scale image to fit the height of the image area */
            img.style.objectFit =
              "fill"; /* Ensure the image stretches to fill both dimensions */
            imageContainer.appendChild(img);
          };
        }
      });

      // Listen for paste event to insert clipboard image
      window.addEventListener("paste", (event) => {
        const items = event.clipboardData && event.clipboardData.items;
        if (!items) return;
        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          if (item.type.indexOf("image") !== -1) {
            const blob = item.getAsFile();
            const img = new Image();
            const url = URL.createObjectURL(blob);
            img.src = url;
            img.onload = () => {
              imageContainer.innerHTML = "";
              img.style.width =
                "100%"; /* Scale image to fit the width of the image area */
              img.style.height =
                "100%"; /* Scale image to fit the height of the image area */
              img.style.objectFit =
                "fill"; /* Ensure the image stretches to fill both dimensions */
              imageContainer.appendChild(img);
            };
            break;
          }
        }
      });

      // Listen for snip image from main process
      window.electronAPI.onSnipImage = (callback) => {
        window.electronAPI._snipImageHandler = (event, imageUrl) =>
          callback(imageUrl);
        window.electronAPI._snipImageListener =
          window.electronAPI._snipImageListener ||
          window.electronAPI._snipImageHandler;
        window.electronAPI._ipcRenderer =
          window.electronAPI._ipcRenderer || require("electron").ipcRenderer;
        window.electronAPI._ipcRenderer.on(
          "snip-image",
          window.electronAPI._snipImageListener
        );
      };
      window.electronAPI.onSnipImage((imageUrl) => {
        if (imageUrl) {
          imageContainer.innerHTML = "";
          const imgObj = new window.Image();
          imgObj.src = imageUrl;
          imgObj.onload = function () {
            const aspectRatio = imgObj.naturalWidth / imgObj.naturalHeight;
            const containerWidth = imageContainer.offsetWidth;
            const containerHeight = imageContainer.offsetHeight;
            let newWidth = containerWidth;
            let newHeight = newWidth / aspectRatio;
            if (newHeight < containerHeight) {
              newHeight = containerHeight;
              newWidth = newHeight * aspectRatio;
            }
            // If newWidth > containerWidth, fit width instead
            if (newWidth > containerWidth) {
              newWidth = containerWidth;
              newHeight = newWidth / aspectRatio;
            }
            const wrapper = document.createElement("div");
            wrapper.className = "crop-wrapper";
            wrapper.style.left = (containerWidth - newWidth) / 2 + "px";
            wrapper.style.top = containerHeight - newHeight + "px";
            wrapper.style.width = newWidth + "px";
            wrapper.style.height = newHeight + "px";
            wrapper.style.position = "absolute";
            wrapper.style.zIndex = "2";
            const img = document.createElement("img");
            img.src = imageUrl;
            img.className = "crop-img";
            img.draggable = false;
            wrapper.appendChild(img);
            const handle = document.createElement("div");
            handle.className = "resize-handle";
            wrapper.appendChild(handle);
            imageContainer.appendChild(wrapper);
            // Drag and resize logic as before...
          };
        }
      });

      // Always show field labels in the textarea, even when user types
      const textInputOverlay = document.getElementById("textInputOverlay");
      const fieldLabels = ["To Find:", "Measure:", "Of Size:", "From:"];
      function enforceFieldLabels() {
        let lines = textInputOverlay.value.split("\n");
        // Ensure there are always four lines
        while (lines.length < fieldLabels.length) {
          lines.push("");
        }
        for (let i = 0; i < fieldLabels.length; i++) {
          let userText = "";
          if (lines[i]) {
            // Extract user text after the label
            const match = lines[i].match(
              new RegExp(`^${fieldLabels[i]}\s*(.*)$`)
            );
            userText = match ? match[1] : "";
          }
          lines[i] = fieldLabels[i] + (userText ? " " + userText : "");
        }
        textInputOverlay.value = lines.slice(0, fieldLabels.length).join("\n");
      }
      textInputOverlay.addEventListener("input", enforceFieldLabels);
      // Initialize with labels, each on its own line
      textInputOverlay.value = fieldLabels.join("\n");

      // For each field, show label as prefix inside textarea and keep it constant
      function enforceConstantLabel(textarea, label) {
        textarea.addEventListener("input", function () {
          let value = textarea.value;
          // Remove any accidental duplicate label
          value = value.replace(new RegExp("^" + label + "\s*"), "");
          textarea.value = label + " " + value;
          // Move cursor after the label
          textarea.setSelectionRange(
            label.length + 1 + value.length,
            label.length + 1 + value.length
          );
        });
        // Prevent user from deleting the label
        textarea.addEventListener("keydown", function (e) {
          if (
            textarea.selectionStart <= label.length + 1 &&
            (e.key === "Backspace" || e.key === "ArrowLeft")
          ) {
            e.preventDefault();
            textarea.setSelectionRange(label.length + 1, label.length + 1);
          }
        });
        // Initialize with label
        textarea.value = label + " ";
        textarea.setSelectionRange(label.length + 1, label.length + 1);
      }
      enforceConstantLabel(document.getElementById("toFindInput"), "To Find:");
      enforceConstantLabel(document.getElementById("measureInput"), "Measure:");
      enforceConstantLabel(document.getElementById("ofSizeInput"), "Of Size:");
      enforceConstantLabel(document.getElementById("fromInput"), "From:");

      // Ensure print styles override inline styles during printing
      function applyPrintImageStyles() {
        const imgs = imageContainer.querySelectorAll("img");
        imgs.forEach((img) => {
          img.style.width = "";
          img.style.height = "";
          img.style.objectFit = "";
          img.style.objectPosition = "";
          img.style.position = "";
          img.style.right = "";
          img.style.bottom = "";
          img.style.left = "";
          img.style.top = "";
          img.style.margin = "";
          img.style.padding = "";
        });
      }
      window.addEventListener("beforeprint", applyPrintImageStyles);
      window.addEventListener("afterprint", () => {
        // Optionally restore app styles after printing if needed
      });

      function padZero(num) {
        return num < 10 ? "0" + num : num;
      }
      function getFormattedDateTime() {
        const now = new Date();
        const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        const months = [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sept",
          "Oct",
          "Nov",
          "Dec",
        ];
        const dayName = days[now.getDay()];
        const monthName = months[now.getMonth()];
        const dayNum = now.getDate();
        // New York (UTC-4)
        const ny = new Date(
          now.toLocaleString("en-US", { timeZone: "America/New_York" })
        );
        const nyHour = padZero(ny.getHours());
        const nyMin = padZero(ny.getMinutes());
        // Israel (UTC+3)
        const il = new Date(
          now.toLocaleString("en-US", { timeZone: "Asia/Jerusalem" })
        );
        const ilHour = padZero(il.getHours());
        const ilMin = padZero(il.getMinutes());
        return `${dayName} ${monthName} ${dayNum} | New York: ${nyHour}:${nyMin} | Israel: ${ilHour}:${ilMin}`;
      }
      window.addEventListener("DOMContentLoaded", function () {
        var printedTextarea = document.getElementById("printedTextarea");
        if (printedTextarea) {
          var formattedDateTime = getFormattedDateTime();
          if (formattedDateTime) {
            console.log(
              "Setting placeholder for Printed textarea:",
              formattedDateTime
            );
            printedTextarea.placeholder = formattedDateTime;
          } else {
            console.warn("Formatted date/time is empty. Using fallback value.");
            printedTextarea.placeholder = "Date not available";
          }
        } else {
          console.error("Printed textarea not found in the DOM.");
        }
      });

      function syncDateTitleLabel() {
        var dateTitleLabel = document.getElementById("dateTitleLabel");
        var datetimeHeader = document.getElementById("datetimeHeader");
        if (dateTitleLabel && datetimeHeader) {
          dateTitleLabel.textContent = datetimeHeader.textContent;
        }
      }
      window.addEventListener("DOMContentLoaded", function () {
        syncDateTitleLabel();
      });
      // Update the label whenever the header changes
      if (datetimeHeader) {
        datetimeHeader.addEventListener("input", syncDateTitleLabel);
      }
      setInterval(syncDateTitleLabel, 10000);

      function copyDateTitle() {
        var originalDateTitle = document.getElementById("datetimeHeader");
        var copiedDateTitle = document.getElementById("copiedDateTitle");
        if (originalDateTitle && copiedDateTitle) {
          copiedDateTitle.textContent = originalDateTitle.textContent;
        }
      }
      window.addEventListener("DOMContentLoaded", function () {
        copyDateTitle();
      });
      // Update the copied title whenever the original changes
      if (datetimeHeader) {
        datetimeHeader.addEventListener("input", copyDateTitle);
      }
      setInterval(copyDateTitle, 10000);

      function updateTestDateLabel() {
        var testDateLabel = document.getElementById("testDateLabel");
        if (testDateLabel) {
          var formattedDateTime = getFormattedDateTime();
          console.log("Updating Test label with date:", formattedDateTime);
          testDateLabel.textContent = formattedDateTime;
        } else {
          console.error("Test label element not found in the DOM.");
        }
      }
      window.addEventListener("DOMContentLoaded", function () {
        console.log(
          "App launched. Attempting to open developer tools console log."
        );
        if (window.electronAPI && window.electronAPI.openDevTools) {
          console.log("Electron API detected. Invoking openDevTools.");
          try {
            window.electronAPI.openDevTools();
          } catch (e) {
            console.error(
              "Failed to open developer tools using Electron API.",
              e
            );
          }
        } else {
          console.warn(
            "Electron API not available. Using browser fallback to open dev tools."
          );
          try {
            console.log("Triggering debugger statement to open dev tools.");
            debugger; // Triggers the browser's developer tools
          } catch (e) {
            console.error("Failed to open developer tools using fallback.", e);
          }
        }
        updateTestDateLabel();
      });
      setInterval(updateTestDateLabel, 10000);
    </script>
  </body>
</html>
